# Getting Started
Create a new project in a `server` with vlquery in it. ([Getting started guide for vlquery](https://github.com/vlvtin/vlquery/blob/master/doc/getting-started.md)).

Install `vlserver` inside the new `server` directory
```
$ npm install --save vlserver
```

Your project should look like this. Add a `package.json` for good measure
```
package.json
server/
	database.ts
	vlconfig.json
	tsconfig.json
	package.json
	package-lock.json
	node_modules/
		...
```

## Server file
We need a main in our server directory, which will be run when we start the application.

```
// server/main.ts

// connect to database and set default client
DbClient.connectedClient = new DbClient({});

console.log("connecting to database...");
DbClient.connectedClient.connect().then(() => {
	console.log("connected!");

	// ManagedServer will be generated by vlserver
	const app = new ManagedServer();

	// Main database context. We will inject this later on
	const db = new DbContext(new RunContext());

	// inject 'db' for DbContext, we need this to access the db context from our services
	app.inject(DbContext, context => db);

	// we'll need this later on when resolving ViewModels back into models
	ViewModel.globalFetchingContext = db;

	// start the application on port 8190
	app.start(+process.env.PORT || 8190);
});
```

## Services and view models
Let's create an `areas` directory, where our services and view models will be created. Create a `book` directory and within the directory a `book.service.ts`

```
// server/areas/book/book.service.ts

export class BookService extends Service {
	constructor(
		private db: DbContext // this will be available because we injected it with 'app.inject' in our servers main
	) {
		super();
	}
}
```

We need some view models too. The ViewModels can contain all or part of the properties and references from our models.
```
// server/areas/book/book.view.ts

export class BookViewModel extends ViewModel<Book> {
	id; // property of Book
	title; // property of Book

	author: AuthorViewModel; // a reference in Book. you'll need to tell vlserver which ViewModel to use
}
```

```
// server/areas/book/author.view.ts

export class AuthorViewModel extends ViewModel<Author> {
	// some properties of Author
	id;
	firstname;
	lastname;
}
```

We have our ViewModels, let's create basic CRUD-methods in our BookService!
```
// server/areas/book/book.service.ts

export class BookService extends Service {
	...

	async getBooks() {
		// use .from for arrays
		// don't put '.toArray' after the query, vlserver will automatically do that
		// vlserver will automatically add the proper '.include' calls to fetch all the data at once
		return BookViewModel.from(await this.db.book);
	}

	// the id parameter will be mapped too
	async getBook(id: string) {
		// for single objects, use the constructor
		return new BookViewModel(await this.db.book.find(id));
	}

	// you can pass ViewModels too
	async createBook(viewModel: BookViewModel) {
		// .toModel will resolve the ViewModel to a Model
		const book = await viewModel.toModel();

		// create the book in the db
		await book.create();

		// return the ViewModel, now containing the books id
		return new BookViewModel(book);
	}

	async updateBook(viewModel: BookViewModel) {
		const book = await viewModel.toModel();

		// update the book in the db
		await book.update();
	}

	async deleteBook(viewModel: BookViewModel) {
		const book = await viewModel.toModel();

		// delete the book in the db
		await book.delete();
	}

	// very unepic search algo
	async search(name: string) {
		const query = this.db.book.toQuery();

		for (let word in name.toLowerCase().trim().split(" ")) {
			query.where(book => 
				book.title.lowercase().includes(word) || 
				book.author.firstname.lowercase().inclues(word) ||
				book.author.lastname.lowercase().inclues(word)
			);
		}

		// make sure to pass the Queryable, not the resolved list!
		// vlserver will have to fetch every "author" of the ViewModel in a single query if you pass a list of Books, which can have a HUGE performance impact, especially when returning a lot of books.
		return BookViewModel.from(query.limit(10));
	}
}
```

## Mapping the service
We need to tell vlserver where and how to map our services. Let's extend our `vlconfig.json`.

Create a `client` directory.

```
// server/vlconfig.json

{
	"context": {
		...
	},
	"services": {
		"serverOutFile": "server.ts",
		"endpoints": [
			{
				"type": "native",
				"outFile": "../client/services.ts"
			}
		]
	}
}
```

> You may have noticed that we set the type to 'native'. There are [other adapters](adapters.md) too!

Now, let's run the compiler
```
$ cd server
$ vlserver compile
```

A `service.ts` file should have been created in `client`.

You can consume the service by using:
```
const service = new BookService();
service.getBooks(); // Promise<Array<BookViewModel>>

const book = await service.getBook("some-id"); // Promise<BookViewModel>
book.title = "A new title";

await service.updateBook(book); // Promise<void>
```

All you'll need to do now is compile the server and run it!
```
$ cd server
$ tsc
$ vlquery compile
$ node dist/main.js
```

Learn how [data is exchanged](exchange.md) between clients and the server.

Have fun!